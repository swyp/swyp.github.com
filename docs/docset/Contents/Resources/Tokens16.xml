<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/swypDiscernedInputStream.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/swypDiscernedInputStream</TokenIdentifier>
			<Abstract type="html">This class allows discrete files to be removed from a flowing NSInputStream.</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>
			
			<NodeRef refid="16"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/swypDiscernedInputStream/setIsIndefinite:</TokenIdentifier>
			<Abstract type="html">	Indefinite streams occur when both endpoints support the same proprietary protocol, and set stream payload length to 0
	When the indefinite stream is to be ended, endIndefiniteStreamAtByteIndex: must be called referencing a byte that has either not yet been read, or has been read in the last read cycle.</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, readonly) BOOL isIndefinite</Declaration>
			
			
			<Anchor>//api/name/isIndefinite</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instp/swypDiscernedInputStream/isIndefinite</TokenIdentifier>
			<Abstract type="html">	Indefinite streams occur when both endpoints support the same proprietary protocol, and set stream payload length to 0
	When the indefinite stream is to be ended, endIndefiniteStreamAtByteIndex: must be called referencing a byte that has either not yet been read, or has been read in the last read cycle.</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>			
			
			<Declaration>@property (nonatomic, readonly) BOOL isIndefinite</Declaration>
			
			
			<Anchor>//api/name/isIndefinite</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/swypDiscernedInputStream/initWithStreamDataSource:type:tag:length:</TokenIdentifier>
			<Abstract type="html">the primary init function</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>			
			
			<Declaration>- (id)initWithStreamDataSource:(id&lt;swypDiscernedInputStreamDataSource&gt;)dataSource type:(NSString *)type tag:(NSString *)tag length:(NSUInteger)streamLength</Declaration>
			
			
			<Anchor>//api/name/initWithStreamDataSource:type:tag:length:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/swypDiscernedInputStream/endIndefiniteStreamAtByteIndex:</TokenIdentifier>
			<Abstract type="html">	This method enables the next input stream to be queued out of data already consumed by reading this object's NSStream
	byteIndex must exist within the most recent read, or in the future
		eg, it can't be from two stream reads back
	Calling this method on a discernedInputStream makes it become definite</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>			
			
			<Declaration>- (void)endIndefiniteStreamAtByteIndex:(NSUInteger)byteIndex</Declaration>
			
			
			<Anchor>//api/name/endIndefiniteStreamAtByteIndex:</Anchor>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/swypDiscernedInputStream/shouldPullData</TokenIdentifier>
			<Abstract type="html">this method tells the discernedInputStream that there is data available, and that it should pull it!</Abstract>
			<DeclaredIn>swypDiscernedInputStream.h</DeclaredIn>			
			
			<Declaration>- (void)shouldPullData</Declaration>
			
			
			<Anchor>//api/name/shouldPullData</Anchor>
		</Token>
		
	</File>
</Tokens>